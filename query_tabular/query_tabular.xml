<tool id="query_tabular" name="Query Tabular" version="0.1.0">
    <description>using sqlite sql</description>

    <requirements>
    </requirements>
    <stdio>
        <exit_code range="1:" />
    </stdio>
    <command interpreter="python"><![CDATA[
        query_tabular.py 
        #if $save_db
        -s $sqlitedb
        #else
        -s $workdb
        #end if
        -j $table_json
        #*
        ##          #for $i,$tbl in enumerate($tables):
        ##            #if $tbl.table_name
        ##            #set $tname = $tbl.table_name
        ##            #else
        ##            #set $tname = 't' + str($i + 1) 
        ##            #end if
        ##            #if $tbl.col_names:
        ##            #set $col_names = ':' + str($tbl.col_names)
        ##            #else 
        ##            #set $col_names = ''
        ##            #end if
        ##            -t ${tbl.table}=${tname}${$col_names}
        ##          #end for
        *#
        #if $sqlquery:
          -Q "$query_file" 
          $no_header
          -o $output
        #end if
    ]]></command>
    <configfiles>
        <configfile name="query_file">
$sqlquery
        </configfile>
        <configfile name="table_json">
#import json
#set $jtbldef = dict()
#set $jtbls = []
#set $jtbldef['tables'] = $jtbls
#for $i,$tbl in enumerate($tables):
  #set $jtbl = dict()
  #set $jtbl['file_path'] = str($tbl.table)
  #if $tbl.table_name
  #set $tname = str($tbl.table_name)
  #else
  #set $tname = 't' + str($i + 1) 
  #end if
  #set $jtbl['table_name'] = $tname
  #if $tbl.col_names:
  #set $col_names = str($tbl.col_names)
  #else 
  #set $col_names = ''
  #end if
  #set $jtbl['column_names'] = $col_names
  #if str($tbl.skip_lines) != '':
    #set $jtbl['comment_lines'] = int($tbl.skip_lines)
  #elif $tbl.table.metadata.comment_lines > 0:
    #set $jtbl['comment_lines'] = int($tbl.table.metadata.comment_lines)
  #end if
  #set $jtbls += [$jtbl]
#end for
#echo $json.dumps($jtbldef)
        </configfile>
    </configfiles>
    <inputs>
        <param name="workdb" type="hidden" value="workdb.sqlite" label=""/>
        <repeat name="tables" title="Add tables" min="1">
            <param name="table" type="data" format="tabular" label="Dataset"/>
            <param name="table_name" type="text" value="" optional="true" label="Table name">
                <help>By default, tables will be named: t1,t2,...,tn</help>
                <validator type="regex" message="Table name should start with a letter and may contain additional letters, digits, and underscores">^[A-Za-z]\w*$</validator>
            </param>
            <!--
            <param name="sel_cols" label="Include columns" type="data_column" multiple="true" data_ref="table" />
            -->
            <param name="col_names" type="text" value="" optional="true" label="Column names">
                <help>By default, table columns will be named: c1,c2,c3,...,cn</help>
                <validator type="regex" message="A List of separated by commas: Column names should start with a letter and may contain additional letters, digits, and underscores">^([A-Za-z]\w*)?(,([A-Za-z]\w*)?)*$</validator>
            </param>
            <param name="skip_lines" type="integer" value="" min="0" optional="true" label="Skip lines" help="Leave blank to use the datatype comment lines metadata" />
        </repeat>
        <param name="sqlquery" type="text" area="true" size="10x80" value="" optional="true" label="SQL Query">
                <help>By default, tables will be named: t1,t2,...,tn</help>
                <sanitizer sanitize="False"/>
                <validator type="regex" message="">^(?i)\s*select\s+.*\s+from\s+.*$</validator>
        </param>
        <param name="no_header" type="boolean" truevalue="-n" falsevalue="" checked="False" label="Omit column headers"/>

        <param name="save_db" type="boolean" truevalue="yes" falsevalue="no" checked="false" label="Save the sqlite database"/>
    </inputs>
    <outputs>
        <data format="sqlite" name="sqlitedb" label="sqlite db of ${on_string}">
            <filter>save_db or not (sqlquery and len(sqlquery) > 0)</filter>
        </data>
        <data format="tabular" name="output" label="query results on ${on_string}">
            <filter>sqlquery and len(sqlquery) > 0</filter>
        </data>
    </outputs>
    <tests>

        <test>
            <repeat name="tables">
                <param name="table" ftype="tabular" value="customers.tsv"/>
                <param name="table_name" value="customers"/>
                <param name="col_names" value="CustomerID,FirstName,LastName,Email,DOB,Phone"/>
            </repeat>
            <repeat name="tables">
                <param name="table" ftype="tabular" value="sales.tsv"/>
                <param name="table_name" value="sales"/>
                <param name="col_names" value="CustomerID,Date,SaleAmount"/>
            </repeat>
            <param name="sqlquery" value="SELECT FirstName,LastName,sum(SaleAmount) as &quot;TotalSales&quot; FROM customers join sales on customers.CustomerID = sales.CustomerID GROUP BY customers.CustomerID ORDER BY TotalSales DESC"/>
            <output name="output" file="sales_results.tsv"/>
        </test>

        <test>
            <repeat name="tables">
                <param name="table" ftype="tabular" value="customers.tsv"/>
                <param name="col_names" value=",FirstName,LastName,,DOB,"/>
            </repeat>
            <repeat name="tables">
                <param name="table" ftype="tabular" value="sales.tsv"/>
            </repeat>
            <param name="sqlquery" value="SELECT FirstName,LastName,sum(t2.c3) as &quot;TotalSales&quot; FROM t1 join t2 on t1.c1 = t2.c1 GROUP BY t1.c1 ORDER BY TotalSales DESC;"/>
            <output name="output" file="sales_results.tsv"/>
        </test>

        <test>
            <repeat name="tables">
                <param name="table" ftype="tabular" value="customers.tsv"/>
                <param name="col_names" value=",FirstName,LastName,,BirthDate,"/>
            </repeat>
            <param name="sqlquery" value="select FirstName,LastName,re_sub('^\d{2}(\d{2})-(\d\d)-(\d\d)','\3/\2/\1',BirthDate) as &quot;DOB&quot; from t1 WHERE re_search('[hp]er',c4)"/>
            <output name="output" file="regex_results.tsv"/>
        </test>

        <test>
            <repeat name="tables">
                <param name="table" ftype="tabular" value="IEDB.tsv"/>
                <param name="table_name" value="iedb"/>
                <param name="col_names" value="ID,allele,seq_num,start,end,length,peptide,method,percentile_rank,ann_ic50,ann_rank,smm_ic50,smm_rank,comblib_sidney2008_score,comblib_sidney2008_rank,netmhcpan_ic50,netmhcpan_rank"/>
            </repeat>
            <repeat name="tables">
                <param name="table" ftype="tabular" value="netMHC_summary.tsv"/>
                <param name="table_name" value="mhc_summary"/>
                <param name="col_names" value="pos,peptide,logscore,affinity,Bind_Level,Protein,Allele"/>
            </repeat>
            <param name="sqlquery" value="select iedb.ID,iedb.peptide,iedb.start,iedb.end,iedb.percentile_rank,mhc_summary.logscore,mhc_summary.affinity,mhc_summary.Bind_Level from iedb left outer join mhc_summary on iedb.peptide = mhc_summary.peptide order by affinity,Bind_Level"/>
            <output name="output" file="query_results.tsv"/>
        </test>

    </tests>
    <help><![CDATA[
=============
Query Tabular
=============

**Inputs**

  Loads tabular datasets into a SQLite_ data base.  

**Outputs**

  The results of a SQL query are output to the history as a tabular file.

  The SQLite_ data base can also be saved and output as a dataset in the history.  


For help in using SQLite_ see:  http://www.sqlite.org/docs.html

**NOTE:** input for SQLite dates input field must be in the format: *YYYY-MM-DD* for example: 2015-09-30

See: http://www.sqlite.org/lang_datefunc.html

**Example** 

  Given 2 tabular datasets: *customers* and *sales*
  
   Dataset *customers*
  
    Table name: "customers"
  
    Column names: "CustomerID,FirstName,LastName,Email,DOB,Phone"
  
    =========== ========== ========== ===================== ========== ============
    #CustomerID FirstName  LastName   Email                 DOB        Phone
    =========== ========== ========== ===================== ========== ============
    1           John       Smith      John.Smith@yahoo.com  1968-02-04 626 222-2222
    2           Steven     Goldfish   goldfish@fishhere.net 1974-04-04 323 455-4545
    3           Paula      Brown      pb@herowndomain.org   1978-05-24 416 323-3232
    4           James      Smith      jim@supergig.co.uk    1980-10-20 416 323-8888
    =========== ========== ========== ===================== ========== ============
  
   Dataset *sales*
  
    Table name: "sales"
  
    Column names: "CustomerID,Date,SaleAmount"
  
    =============  ============  ============
      #CustomerID    Date          SaleAmount
    =============  ============  ============
               2    2004-05-06         100.22
               1    2004-05-07          99.95
               3    2004-05-07         122.95
               3    2004-05-13         100.00
               4    2004-05-22         555.55
    =============  ============  ============
  
  The query
  
  ::
  
    SELECT FirstName,LastName,sum(SaleAmount) as "TotalSales" 
    FROM customers join sales on customers.CustomerID = sales.CustomerID 
    GROUP BY customers.CustomerID ORDER BY TotalSales DESC;
  
  Produces this tabular output:
  
    ========== ======== ==========
    #FirstName LastName TotalSales
    ========== ======== ==========
    James      Smith    555.55
    Paula      Brown    222.95
    Steven     Goldfish 100.22
    John       Smith    99.95
    ========== ======== ==========
  
  
  If the optional Table name and Column names inputs are not used, the query would be:
  
  ::
  
    SELECT t1.c2 as "FirstName", t1.c3 as "LastName", sum(t2.c3) as "TotalSales" 
    FROM t1 join t2 on t1.c1 = t2.c1 
    GROUP BY t1.c1 ORDER BY TotalSales DESC;
  
  You can selectively name columns, e.g. on the customers input you could just name columns 2,3, and 5: 
  
    Column names: ,FirstName,LastName,,BirthDate
  
    Results in the following data base table
  
    =========== ========== ========== ===================== ========== ============
    #c1         FirstName  LastName   c4                    BirthDate  c6
    =========== ========== ========== ===================== ========== ============
    1           John       Smith      John.Smith@yahoo.com  1968-02-04 626 222-2222
    2           Steven     Goldfish   goldfish@fishhere.net 1974-04-04 323 455-4545
    3           Paula      Brown      pb@herowndomain.org   1978-05-24 416 323-3232
    4           James      Smith      jim@supergig.co.uk    1980-10-20 416 323-8888
    =========== ========== ========== ===================== ========== ============

  Regular_expression_ functions are included for: 

  ::

    matching:      re_match('pattern',column) 

    SELECT t1.FirstName, t1.LastName
    FROM t1
    WHERE re_match('^.*\.(net|org)$',c4)

  Results:

    =========== ==========
    #FirstName  LastName
    =========== ==========
    Steven      Goldfish
    Paula       Brown
    =========== ==========


  ::

    searching:     re_search('pattern',column)
    substituting:  re_sub('pattern','replacement,column)

    SELECT t1.FirstName, t1.LastName, re_sub('^\d{2}(\d{2})-(\d\d)-(\d\d)','\3/\2/\1',BirthDate) as "DOB"
    FROM t1
    WHERE re_search('[hp]er',c4)

  Results:

    =========== ========== ==========
    #FirstName  LastName   DOB
    =========== ========== ==========
    Steven      Goldfish   04/04/74
    Paula       Brown      24/05/78
    James       Smith      20/10/80
    =========== ========== ==========

.. _Regular_expression: https://docs.python.org/release/2.7/library/re.html
.. _SQLite: http://www.sqlite.org/index.html

    ]]></help>
</tool>
